<!DOCTYPE node PUBLIC "-//freedesktop//DTD D-BUS Object Introspection 1.0//EN"
 "http://www.freedesktop.org/standards/dbus/1.0/introspect.dtd">

<!--
 * This is the well known dbus service name for controlling the
 * entire daemon. The service manages crashes.
-->
<tp:spec xmlns:tp="http://telepathy.freedesktop.org/wiki/DbusSpec#extensions-v0">
    <tp:title>Problems API v2 Specification</tp:title>
    <tp:version>0.2</tp:version>
    <tp:copyright>
      Copyright (C) 2012, 2015 Red Hat
    </tp:copyright>
    <tp:copyright>
      Copyright (C) 2012, 2015 ABRT Team &lt;crash-catcher@lists.fedorahosted.org&gt;
    </tp:copyright>

    <!--
     * ======================================================================================
     * Problems Service Interface
     *
    -->

    <node name='/org/freedesktop/Problems2'>

        <interface name='org.freedesktop.Problems2'>
            <tp:docstring>The Problems Service manages all the crashes.</tp:docstring>

            <method name='NewProblem'>
                <tp:docstring>Creates a new problem and returns it's identifier.</tp:docstring>

                <arg type='a{sv}' name='problem_data' direction='in'>
                    <tp:docstring>
                        A dictionary describing problem where values are either file descriptors or strings. There are few commonly recognized fields but the dictionary can hold anything you need.
                        <variablelist>
                            <varlistentry>
                                <term>analyzer</term>
                                <listitem>
                                    <para>This field should be always present. The field defines a type of problem. If the item is not provided, <emphasis role="bold">libreport</emphasis> string is used by default.</para>
                                </listitem>
                            </varlistentry>
                            <varlistentry>
                                <term>reason</term>
                                <listitem>
                                    <para>This field should contain a short human readable text describing the problem.</para>
                                </listitem>
                            </varlistentry>
                            <varlistentry>
                                <term>time</term>
                                <listitem>
                                    <para>This field is filled automaticaly.</para>
                                </listitem>
                            </varlistentry>
                            <varlistentry>
                                <term>uid</term>
                                <listitem>
                                    <para>Only a user with root privileges can pass this field. For all other users the field is filled by caller's uid.</para>
                                </listitem>
                            </varlistentry>
                            <varlistentry>
                                <term>executable</term>
                                <listitem>
                                    <para>This is mandatory field and must contain a valid path to an executable.</para>
                                </listitem>
                            </varlistentry>
                            <varlistentry>
                                <term>component</term>
                                <listitem>
                                    <para>A name of package which a problematic application belongs to. If this field is provided, <emphasis role="bold">the executable field becomes optional</emphasis>.</para>
                                </listitem>
                            </varlistentry>
                            <varlistentry>
                                <term>uuid</term>
                                <listitem>
                                    <para>Machine readable identifier of a kind of the problem. ABRT uses this field for <emphasis role="bold">local duplicates searching</emphasis>.</para>
                                </listitem>
                            </varlistentry>
                            <varlistentry>
                                <term>duphash</term>
                                <listitem>
                                    <para>Machine readable identifier of a kind of the problem. ABRT uses this field for <emphasis role="bold">global duplicates searching</emphasis>.</para>
                                </listitem>
                            </varlistentry>
                        </variablelist>
                    </tp:docstring>
                </arg>
                <annotation name="org.qtproject.QtDBus.QtTypeName.In0" value="QHash&lt;QString,QString&gt;"/>

                <arg type='s' name='problem_id' direction='out'>
                    <tp:docstring>An indentifier of the new problem</tp:docstring>
                </arg>

                <!-- TODO fix these examples -->

                <tp:docstring>
                    <example id="NewProblem_example_python">
                        <title>How to create a new problems in Python</title>
                        <programlisting>
<![CDATA[
#!/usr/bin/env python
import dbus

bus = dbus.SystemBus()

proxy = bus.get_object("org.freedesktop.problems",
                                  '/org/freedesktop/problems2')

problems = dbus.Interface(proxy, dbus_interface='org.freedesktop.Problems2')

description = {"analyzer"    : "libreport",
               "reason"      : "Application has been killed",
               "backtrace"   : "die()",
               "executable"  : "/usr/bin/foo"}

problems.NewProblem(description)
]]>
                        </programlisting>
                    </example>
                    <example id="NewProblem_example_bash">
                        <title>How to create a new problems in Bash</title>
                        <programlisting>
<![CDATA[
#!/usr/bin/bash
dbus-send --system --type=method_call --print-reply \
          --dest=org.freedesktop.problems /org/freedesktop/problems2 \
          org.freedesktop.Problems2.NewProblem \
          dict:string:string:analyzer,libreport,reason,"Application has been killed",backtrace,"die()",executable,"/usr/bin/true"
]]>
                        </programlisting>
                    </example>
                </tp:docstring>
            </method>


            <method name='GetProblems'>
                <tp:docstring>Returns a list of problem identifiers for problems visible by the caller. If the session is authorized (GetSession), then the method returns all detected problems (system problems and problems of other users).</tp:docstring>

                <arg type='ao' name='response' direction='out'>
                    <tp:docstring>List of problem identifiers</tp:docstring>
                </arg>

                <tp:docstring>
                    <example id="GetProblems_example_python">
                        <title>How to get the list of problems in Python</title>
                        <programlisting>
<![CDATA[
#!/usr/bin/env python
import dbus

bus = dbus.SystemBus()

proxy = bus.get_object("org.freedesktop.problems",
                                  '/org/freedesktop/problems2')

problems = dbus.Interface(proxy, dbus_interface='org.freedesktop.Problems2')
prblms = problems.GetProblems()

for path in prblms:
    prblm_proxy = dbus.get_object("org.freedesktop.problems", path)
    prblm = dbus.Interface(prblm_proxy, "org.freedesktop.Problems2.Entry")

    print(prblm.executable)
    print(prblm.reason)
    print()
]]>
                        </programlisting>
                    </example>
                </tp:docstring>

                <tp:docstring>
                    <example id="GetProblems_authorized_example_python">
                        <title>How to get the list of user problems and system problems in Python</title>
                        <programlisting>
<![CDATA[
#!/usr/bin/env python
import sys
import dbus

bus = dbus.SystemBus()

proxy = bus.get_object("org.freedesktop.problems",
                                  '/org/freedesktop/problems2')

problems = dbus.Interface(proxy, dbus_interface='org.freedesktop.Problems2')

session_path = problems.GetSession()

session_proxy = bus.get_object("org.freedesktop.problems", session_path)
session = dbus.Interface(session_proxy, dbus_interface='org.freedesktop.Problems2.Session')

result = session.Authorize(None, True)
if result != 0:
    print("Cannot authorize")
    sys.exit(1)

prblms = problems.GetProblems()

for path in prblms:
    prblm_proxy = dbus.get_object("org.freedesktop.problems", path)
    prblm = dbus.Interface(prblm_proxy, "org.freedesktop.Problems2.Entry")

    print(prblm.executable)
    print(prblm.reason)
    print()
]]>
                        </programlisting>
                    </example>
                </tp:docstring>

            </method>

            <method name='GetProblemData'>
                <tp:docstring>Gets an equivalent of libreport's ProblemData for the given problem entry.</tp:docstring>

                <arg type='o' name='problem_object' direction='in'>
                    <tp:docstring>Problem Entry path used to get the problem data.</tp:docstring>
                </arg>

                <arg type='a{s(its)}' name='problem_data' direction='out'>
                    <tp:docstring>The results is a dicitionary where the key is problem element name (e.g. package, maps, coredump) and the value is a structure with three members:
                    <orderedlist>
                        <listitem><para>libreport's flags (problem_data.h)</para></listitem>
                        <listitem><para>element size in Bytes</para></listitem>
                        <listitem><para>element's contents (data for CD_FLAG_TXT, file path for CD_FLAG_BIN and CD_FLAG_BIGTXT)</para></listitem>
                    </orderedlist>
                    </tp:docstring>
                </arg>
            </method>
            <method name='DeleteProblems'>
                <tp:docstring>Deletes specified problems. The problems are specified as array of problem objects.</tp:docstring>

                <arg type='ao' name='problem_objects' direction='in'>
                    <tp:docstring>An array of problem objecsts to deleted.</tp:docstring>
                </arg>
            </method>

            <signal name='Crash'>
                <tp:docstring>A new system problem has been detected.</tp:docstring>

                <arg type='o' name='problem_object' direction='out'>
                    <tp:docstring>An identifier of the newly created problem.</tp:docstring>
                </arg>

                <arg type='s' name='uid' direction='out'>
                    <tp:docstring>UID of user who reported this problem.</tp:docstring>
                </arg>
            </signal>

        </interface>

    </node>

    <!--
     * ======================================================================================
     * Problems Entry Interface
     *
    -->

    <node name='/org/freedesktop/Problems2/xxx'>

        <interface name='org.freedesktop.Problems2.Entry'>
            <tp:docstring>The Entry represents single problem.</tp:docstring>

            <property name='id' type='s' access='read'>
                <tp:docstring>The unix time when the collection was created.</tp:docstring>
            </property>

            <property name='uid' type='u' access='read'>
                <tp:docstring>The uid of the crashed program.</tp:docstring>
            </property>

            <property name='username' type='s' access='read'>
                <tp:docstring>The user name associated with the uid.</tp:docstring>
            </property>

            <property name='type' type='s' access='read'>
                <tp:docstring>The type of the problem (CCpp, Python, Kerneloops, Java, Ruby).</tp:docstring>
            </property>

            <property name='detected' type='t' access='read'>
                <tp:docstring>The unix time when the problem entry was created.</tp:docstring>
            </property>

            <property name='last_occurrence' type='t' access='read'>
                <tp:docstring>The unix time when the problem entry was seen for the last time.</tp:docstring>
            </property>

            <property name='count' type='u' access='read'>
                <tp:docstring>The number of observed problem's occurrences.</tp:docstring>
            </property>

            <property name='executable' type='s' access='read'>
                <tp:docstring>The file system path to crashed program.</tp:docstring>
            </property>

            <property name='command_line_arguments' type='s' access='read'>
                <tp:docstring>The command line arguments used run the crashed program.</tp:docstring>
            </property>

            <property name='component' type='s' access='read'>
                <tp:docstring>The component which the package belogns to.</tp:docstring>
            </property>

            <property name='package' type='(sssss)' access='read'>
                <tp:docstring>Information about the package which the crashed program belongs to:
                <orderedlist>
                    <listitem><para>full name</para></listitem>
                    <listitem><para>epoch</para></listitem>
                    <listitem><para>name</para></listitem>
                    <listitem><para>version</para></listitem>
                    <listitem><para>release</para></listitem>
                </orderedlist>
                </tp:docstring>
            </property>

            <property name='uuid' type='s' access='read'>
                <tp:docstring>A local scope, unique identifier for similar problems to the problem.</tp:docstring>
            </property>

            <property name='duphash' type='s' access='read'>
                <tp:docstring>A global scope, unique identifier for similar problems to the problem.</tp:docstring>
            </property>

<!--
Property "reports":
===================
libreports 'repoted_to' contains known reports of a problem. Every report is
stored in a form of a single line. Every 'reported_to' line is prefixed with
"label" followed ":". We will use term 'title' instead of 'label.
libreport recognizes three value types on lines of 'reported_to' element:
1. text message
2. URL (Bugzilla, e-mail, upload, RHSupport)
3. BTHASH (uReport)

One might presume the list will grow in the future with the growing number of
report types and supported bug trackers. Hence the API should not have
hard-coded types and should be able to easily start supporting new
'reported_to' types. This goal is in D-Bus APIs achieved by using dictionaries
with the value of the type Variant and a string key (a{sv}).

Know keys:
    * MSG - a text description of the report
    * URL - an URL to the report
    * BTHASH - a global uReport identifier

The final type of the property 'reports' would be "a(sa{sv})".

Example:

file "reported_to":
    Bugzilla: URL=https://bugzill.example.com/1000000
    Bugzilla: URL=https://bugzill.example.com/1234567
    email: URL=mailto://bugs@example-project.org
    ABRT Server: BTHASH=DEADBEFF81680083
    RHTSupport: URL=https://support.corp.com/ticket=12345 MSG=New customer case 12345

property "reports":
    [
        ( "Bugzilla",
            { "URL" : "https://bugzill.example.com/1000000" }
        ),
        ( "Bugzilla",
            { "URL" : "https://bugzill.example.com/1234567" },
        ),
        ( "email",
            { "URL" : "mailto://bugs@example-project.org" }
        ),
        ( "ABRT Server",
            { "BTHASH" : "DEADBEFF81680083" },
        ),
        ( "RHTSupport",
            { "URL" : "https://support.corp.com/ticket=12345",
              "MSG" : "New customer case 12345" }
        )
    ]

Note:

We will not convert the format of reported_to to JSON and use it for storing
solutions, because the solutions will have own element and the file reported_to
is just a list of reports and should not be overloaded.
-->

<!--
We have to provide a way to edit the reports (add/remove/update) without
the need to touch raw data.
====
SetSemanticElement() provides the way to modify 'reports' property.
-->
            <property name='reports' type='a{sa{sv}}' access='read'>
                <tp:docstring>The list of reports of the problem in the form of a dictionary where the key is the report type (e.g. Bugzilla, ABRT Server) and the value is another dictionary with the report informations (URL, "https://bugzilla.redhat.com/1000000").</tp:docstring>
            </property>

            <property name='reason' type='s' access='read'>
                <tp:docstring>A brief description of what caused the problem.</tp:docstring>
            </property>

            <property name='resolution' type='s' access='read'>
                <tp:docstring>More technical details about the problem usally containing explanation for the not-reporatiblity of the problem (e.g tainted Kernel oopses).</tp:docstring>
            </property>

            <property name='desktop_file' type='s' access='read'>
                <tp:docstring>The name of system desktop file used to start the program. This property is set to some value only if the program was started as an application, the application was found and the program is shipped with a system package (i.e. this property is empty for crashes of user application).</tp:docstring>
            </property>

            <property name='elements' type='as' access='read'>
                <tp:docstring>List of all elements the problem data contains.</tp:docstring>
            </property>

            <property name='semantic_elements' type='as' access='read'>
                <tp:docstring>List of supported semantic elements.</tp:docstring>
            </property>

            <property name='is_reported' type='b' access='read'>
                <tp:docstring>True if someone took the time to file a ticket in the bugctracking system of OS.</tp:docstring>
            </property>

            <property name='is_reportable' type='b' access='read'>
                <tp:docstring>True if it is possible to file a ticket in the bugctracking system of OS.</tp:docstring>
            </property>
<!--
Generic property getter
=======================

It is expectable that we will need to add new properties. We can handle it by
adding a new D-Bus property and force consumers to write their code ready for
the missing properties or we can add a method returning variant or better a{sv}.
-->
            <method name='GetSemanticElement'>
                <tp:docstring>Gets semantic values of problem's elements. Each implementation of 'org.freedesktop.Problems2' supports their own Semantic Elements.</tp:docstring>

                <arg type='as' name='element_names' direction='in'>
                    <tp:docstring>Requested element names.</tp:docstring>
                </arg>

                <arg type='a{sv}' name='values' direction='out'>
                    <tp:docstring>A dictionary where keys are element names and values depend on the implementation of 'org.freedesktop.Problems2'.</tp:docstring>
                </arg>
            </method>

            <method name='SetSemanticElement'>
                <tp:docstring>Sets semantic value of problem's elements. Each implementation of 'org.freedesktop.Problems2' supports their own Semantic Elements.</tp:docstring>

                <arg type='a{sv}' name='values' direction='in'>
                    <tp:docstring>A dictionary where keys are element names and values depend on the implementation of 'org.freedesktop.Problems2'.</tp:docstring>
                </arg>
            </method>
<!--
Getters and setters
===================
We need to decided whether we want have more, specialized functions or less,
configurable functions. According to D-Bus API Design Guidelines, it is a good
idea to use flag fields in method calls.

There is a question that needs to be answered for both approaches:
1. What should happen if the caller wants an element of not supported type?


Use the type Variable in the getters:
`````````````````````````````````````
method GetTextElements(in as, out a{ss})
    returns a list of values of text elements
    1. return an error or treat it as missing

and method OpenElements(in as, out a{su})
    returns a list of file descriptors to both kind of elements
    1. everything is a file descriptor, so the caller has to recognize the
       type of the elements on his own

OR:

method ReadElements(in asi, out a{sv})
    returns binary elements as UNIX file descriptors and text elements as strings
    i == flags
        * NO FLAGS -> open both binary and text elements
        * ALL FD -> return everything as UNIX file descriptors
        * ONLY TEXT -> get only text elements
        * ONLY BINARY -> get only binary elements
        ? ONLY BIG TEXT -> or treat this as BINARY?

    1. client has to recognize the return type and behave appropriately
     1.a (ONLY TEXT) return an error or treat it as missing
     1.b (ONLY TEXT | ALL FD) the caller knows what to do
     1.c (ONLY BINARY) the caller has to recognize the type of the elements on
         his own
     1.d (ONLY BINARY | ALL FD) the same as 1.c

The method ReadElements is more error prone because clients need to write code
checking the return type. But the method is more flexible because of the
argument flags, so it would be better to use this variant.


Use the type Variable in the setters:
`````````````````````````````````````
method SaveTextElements(in ass)
method SaveElements(in asu)

OR:

method SaveElements(in asv)

The Variable variant is definitely more convenient for users!
-->

            <method name='ReadElements'>
                <tp:docstring>Gets a raw value of problem's element.</tp:docstring>

                <arg type='as' name='element_names' direction='in'>
                    <tp:docstring>A list of names of required info. If type of a requested element does not match the type specified in the argument 'i', the element will be ignored and its value will not be included in the response.</tp:docstring>
                </arg>

                <arg type='i' name='flags' directory='in'>
                    <tp:docstring>Enables selection of the allowed type and the type of return values.
                        <variablelist>
                            <varlistentry>
                                <term>0 : NO_FLAGS</term>
                                <listitem><para>Do not check element types and return text elements as D-Bus strings, big text elements as UNIX file descriptors and binary elements as UNIX file descriptors too.</para></listitem>
                            </varlistentry>
                            <varlistentry>
                                <term>1 : ALL_FD</term>
                                <listitem><para>The returned values will be file descriptors for all element types (text, big text and binary)</para></listitem>
                            </varlistentry>
                            <varlistentry>
                                <term>2 : ALL_TYPES</term>
                                <listitem><para>(TODO : I am not sure what I had on mind. I will remove this term later.)</para></listitem>
                            </varlistentry>
                            <varlistentry>
                                <term>4 : ONLY_TEXT</term>
                                <listitem><para>Only those elements that are of text type are read and their contents are returned as D-Bus strings by default.</para></listitem>
                            </varlistentry>
                            <varlistentry>
                                <term>8 : ONLY_BIG_TEXT</term>
                                <listitem><para>Only those elements that are of binary type are read and their contents are returned as UNIX file descriptors</para></listitem>
                            </varlistentry>
                            <varlistentry>
                                <term>16 : ONLY_BINARY</term>
                                <listitem><para>Only those elements that are of big text type are read and their contents are returned as UNIX file descriptors</para></listitem>
                            </varlistentry>
                        </variablelist>
                    </tp:docstring>
                </arg>

                <arg type='a{sv}' name='response' direction='out'>
                    <tp:docstring>A list of values of the requested elements.</tp:docstring>
                </arg>
                <tp:docstring>
                    <example id="ReadElements_example_python">
                        <title>How to use ReadElements() method to print out a nice list of problems</title>
                        <programlisting>
<![CDATA[
#!/usr/bin/env python
from sys import stdout
import dbus
from datetime import datetime

bus = dbus.SystemBus()

proxy = bus.get_object("org.freedesktop.problems",
                          '/org/freedesktop/problems2')

problems = dbus.Interface(proxy, dbus_interface='org.freedesktop.Problems2')

for prblmprx in problems.GetProblems():
    prblm  = dbus.Interface(prblmprx, dbus_interface='org.freedesktop.Problems.Entry')
    kv = prblm.ReadElements(prblmid, ["time", "count", "package", "reason"], ONLY_TEXT)

    date = datetime.fromtimestamp(float(kv["time"]))
    count = int(kv.get("count", 0))
    package = str(kv.get("package", ""))
    reason = str(kv.get("reason", ""))

    stdout.write("{0} {1:-3} {2:30} : {3}\n".format(date, count, package, reason))
]]>
                        </programlisting>
                    </example>
                </tp:docstring>

            </method>

            <method name='SaveElements'>
                <tp:docstring>Creates or updates raw values of the given problem elements</tp:docstring>

                <arg type='a{sv}' name='elements' direction='in'>
                    <tp:docstring>The problem elements and their values of one of the fllowing types:
                    <variablelist>
                        <varlistentry>
                            <term>s</term>
                            <listitem><para>text data</para></listitem>
                        </varlistentry>
                        <varlistentry>
                            <term>ay</term>
                            <listitem><para>binary data</para></listitem>
                        </varlistentry>
                        <varlistentry>
                            <term>h</term>
                            <listitem><para>file descriptor</para></listitem>
                        </varlistentry>
                    </variablelist>
                   </tp:docstring>
                </arg>

                <arg type='i' name='flags' direction='in'>
                    <tp:docstring>This argument can be used in future to allow the caller to choose whether he want to append the elements or truncate them.</tp:docstring>
                </arg>

            </method>

            <method name='DeleteElements'>
                <tp:docstring>Deletes problem's element.</tp:docstring>

                <arg type='as' name='name' direction='in'>
                    <tp:docstring>The list of deleted problem element.</tp:docstring>
                </arg>

            </method>

        </interface>

    </node>

    <!--
     * ======================================================================================
     * Session Interface
     *
    -->

    <node name='/org/freedesktop/Problems2/session/xxx'>

        <interface name='org.freedesktop.Problems2.Session'>
            <tp:docstring>Session objects hold information about identity of clients. A session object is created automatically when a new client makes connection. Clients are treated as an anonymous users until they are authorized in 'Authorize' method.</tp:docstring>

            <property name='is_authorized' type='b' access='read'>
                <tp:docstring>TRUE if the client is authorized; otherwise FALSE.</tp:docstring>
            </property>

            <method name='Authorize'>
                <tp:docstring></tp:docstring>

                <arg type='s' name='window-id' direction='in'>
                    <tp:docstring>A window handle to use when showing a pop up.</tp:docstring>
                </arg>

                <arg type='b' name='synchronous' direction='in'>
                    <tp:docstring>If FALSE, the method returns immediately after an authorization request is accepted; otherwise the method blocks until the authorization request is finished.</tp:docstring>
                </arg>

                <arg type='i' name='result' direction='out'>
                    <tp:docstring>
                        <variablelist>
                            <varlistentry>
                                <term>-1</term>
                                <listitem><para>An error occurred</para></listitem>
                            </varlistentry>
                            <varlistentry>
                                <term>0</term>
                                <listitem><para>The authorization request has succeeded and the client is now authorized.</para></listitem>
                            </varlistentry>
                            <varlistentry>
                                <term>1</term>
                                <listitem><para>The authorization request has been accepted (only if the synchronous argument was TRUE).</para></listitem>
                            </varlistentry>
                            <varlistentry>
                                <term>2</term>
                                <listitem><para>The previous authorization request is not finished yet (only if the synchronous argument was TRUE).</para></listitem>
                            </varlistentry>
                        </variablelist>
                    </tp:docstring>
                </arg>
            </method>

            <method name='Close'>
                <tp:docstring>Disposes the current session object and drops all authorization tokens. If the client makes a further action, a new session object on the same path will be created.</tp:docstring>
            </method>

            <signal name='AuthorizationChanged'>
                <tp:docstring>Notifies the changes of state of authorization.</tp:docstring>

                <arg type='i' name='status' direction='out'>
                    <tp:docstring>Describes the change that happened and can be one of the following values:
                        <variablelist>
                            <varlistentry>
                                <term>-1</term>
                                <listitem><para>The recent authorization request has failed.</para></listitem>
                            </varlistentry>
                            <varlistentry>
                                <term>0</term>
                                <listitem><para>The recent authorization request has succeeded and the client is now authorized.</para></listitem>
                            </varlistentry>
                            <varlistentry>
                                <term>1</term>
                                <listitem><para>Authorization has been lost.</para></listitem>
                            </varlistentry>
                        </variablelist>
                    </tp:docstring>
                </arg>
            </signal>
        </interface>

    </node>

</tp:spec>
