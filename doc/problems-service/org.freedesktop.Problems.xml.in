<!DOCTYPE node PUBLIC "-//freedesktop//DTD D-BUS Object Introspection 1.0//EN"
 "http://www.freedesktop.org/standards/dbus/1.0/introspect.dtd">

<!--
 * This is the well known dbus service name for controlling the
 * entire daemon. The service manages crashes.
-->
<tp:spec xmlns:tp="http://telepathy.freedesktop.org/wiki/DbusSpec#extensions-v0">
    <tp:title>Problems API v2 Specification</tp:title>
    <tp:version>0.2</tp:version>
    <tp:copyright>
      Copyright (C) 2012, 2015 Red Hat
    </tp:copyright>
    <tp:copyright>
      Copyright (C) 2012, 2015 ABRT Team &lt;crash-catcher@lists.fedorahosted.org&gt;
    </tp:copyright>

    <!--
     * ======================================================================================
     * Problems Service Interface
     *
    -->

    <node name='/org/freedesktop/Problems2'>

        <interface name='org.freedesktop.Problems2'>
            <tp:docstring>The Problems Service manages all the crashes.</tp:docstring>

            <method name='NewProblem'>
                <tp:docstring>Creates a new problem and returns it's identifier.</tp:docstring>

                <arg type='a{sv}' name='problem_data' direction='in'>
                    <tp:docstring>
                        A dictionary describing problem where values are either file descriptors or strings. There are few commonly recognized fields but the dictionary can hold anything you need.
                        <variablelist>
                            <varlistentry>
                                <term>analyzer</term>
                                <listitem>
                                    <para>This field should be always present. The field defines a type of problem. If the item is not provided, <emphasis role="bold">libreport</emphasis> string is used by default.</para>
                                </listitem>
                            </varlistentry>
                            <varlistentry>
                                <term>reason</term>
                                <listitem>
                                    <para>This field should contain a short human readable text describing the problem.</para>
                                </listitem>
                            </varlistentry>
                            <varlistentry>
                                <term>time</term>
                                <listitem>
                                    <para>This field is filled automaticaly.</para>
                                </listitem>
                            </varlistentry>
                            <varlistentry>
                                <term>uid</term>
                                <listitem>
                                    <para>Only a user with root privileges can pass this field. For all other users the field is filled by caller's uid.</para>
                                </listitem>
                            </varlistentry>
                            <varlistentry>
                                <term>executable</term>
                                <listitem>
                                    <para>This is mandatory field and must contain a valid path to an executable.</para>
                                </listitem>
                            </varlistentry>
                            <varlistentry>
                                <term>component</term>
                                <listitem>
                                    <para>A name of package which a problematic application belongs to. If this field is provided, <emphasis role="bold">the executable field becomes optional</emphasis>.</para>
                                </listitem>
                            </varlistentry>
                            <varlistentry>
                                <term>uuid</term>
                                <listitem>
                                    <para>Machine readable identifier of a kind of the problem. ABRT uses this field for <emphasis role="bold">local duplicates searching</emphasis>.</para>
                                </listitem>
                            </varlistentry>
                            <varlistentry>
                                <term>duphash</term>
                                <listitem>
                                    <para>Machine readable identifier of a kind of the problem. ABRT uses this field for <emphasis role="bold">global duplicates searching</emphasis>.</para>
                                </listitem>
                            </varlistentry>
                        </variablelist>
                    </tp:docstring>
                </arg>
                <annotation name="org.qtproject.QtDBus.QtTypeName.In0" value="QHash&lt;QString,QString&gt;"/>

                <arg type='s' name='problem_id' direction='out'>
                    <tp:docstring>An indentifier of the new problem</tp:docstring>
                </arg>

                <!-- TODO fix these examples -->

                <tp:docstring>
                    <example id="NewProblem_example_python">
                        <title>How to create a new problems in Python</title>
                        <programlisting>
<![CDATA[
#!/usr/bin/env python
import dbus

bus = dbus.SystemBus()

proxy = bus.get_object("org.freedesktop.problems",
                                  '/org/freedesktop/problems2')

problems = dbus.Interface(proxy, dbus_interface='org.freedesktop.Problems2')

description = {"analyzer"    : "libreport",
               "reason"      : "Application has been killed",
               "backtrace"   : "die()",
               "executable"  : "/usr/bin/foo"}

problems.NewProblem(description)
]]>
                        </programlisting>
                    </example>
                    <example id="NewProblem_example_bash">
                        <title>How to create a new problems in Bash</title>
                        <programlisting>
<![CDATA[
#!/usr/bin/bash
dbus-send --system --type=method_call --print-reply \
          --dest=org.freedesktop.problems /org/freedesktop/problems2 \
          org.freedesktop.Problems2.NewProblem \
          dict:string:string:analyzer,libreport,reason,"Application has been killed",backtrace,"die()",executable,"/usr/bin/true"
]]>
                        </programlisting>
                    </example>
                </tp:docstring>
            </method>


            <method name='GetProblems'>
                <tp:docstring>Returns a list of problem identifiers for problems visible by the caller. If the session is authorized (GetSession), then the method returns all detected problems (system problems and problems of other users).</tp:docstring>

                <arg type='ao' name='response' direction='out'>
                    <tp:docstring>List of problem identifiers</tp:docstring>
                </arg>

                <tp:docstring>
                    <example id="GetProblems_example_python">
                        <title>How to get the list of problems in Python</title>
                        <programlisting>
<![CDATA[
#!/usr/bin/env python
import dbus

bus = dbus.SystemBus()

proxy = bus.get_object("org.freedesktop.problems",
                                  '/org/freedesktop/problems2')

problems = dbus.Interface(proxy, dbus_interface='org.freedesktop.Problems2')
prblms = problems.GetProblems()

for path in prblms:
    prblm_proxy = dbus.get_object("org.freedesktop.problems", path)
    prblm = dbus.Interface(prblm_proxy, "org.freedesktop.Problems2.Entry")

    print(prblm.executable)
    print(prblm.reason)
    print()
]]>
                        </programlisting>
                    </example>
                </tp:docstring>

                <tp:docstring>
                    <example id="GetProblems_authorized_example_python">
                        <title>How to get the list of user problems and system problems in Python</title>
                        <programlisting>
<![CDATA[
#!/usr/bin/env python
import sys
import dbus

bus = dbus.SystemBus()

proxy = bus.get_object("org.freedesktop.problems",
                                  '/org/freedesktop/problems2')

problems = dbus.Interface(proxy, dbus_interface='org.freedesktop.Problems2')

session_path = problems.GetSession()

session_proxy = bus.get_object("org.freedesktop.problems", session_path)
session = dbus.Interface(session_proxy, dbus_interface='org.freedesktop.Problems2.Session')

result = session.Authorize(None, True)
if result != 0:
    print("Cannot authorize")
    sys.exit(1)

prblms = problems.GetProblems()

for path in prblms:
    prblm_proxy = dbus.get_object("org.freedesktop.problems", path)
    prblm = dbus.Interface(prblm_proxy, "org.freedesktop.Problems2.Entry")

    print(prblm.executable)
    print(prblm.reason)
    print()
]]>
                        </programlisting>
                    </example>
                </tp:docstring>

            </method>

            <method name='GetProblemData'>
                <tp:docstring>Gets an equivalent of libreport's ProblemData for the given problem entry.</tp:docstring>

                <arg type='o' name='problem_object' direction='in'>
                    <tp:docstring>Problem Entry path used to get the problem data.</tp:docstring>
                </arg>

                <arg type='a{s(its)}' name='problem_data' direction='out'>
                    <tp:docstring>The results is a dicitionary where the key is problem element name (e.g. package, maps, coredump) and the value is a structure with three members. The first one is libreport's flags (problem_data.h), the second one is element size in Bytes and the last one is element's contents (data for CD_FLAG_TXT, file path for CD_FLAG_BIN and CD_FLAG_BIGTXT)</tp:docstring>
                </arg>
            </method>
            <method name='DeleteProblems'>
                <tp:docstring>Deletes specified problems. The problems are specified as array of problem objects.</tp:docstring>

                <arg type='ao' name='problem_objects' direction='in'>
                    <tp:docstring>An array of problem objecsts to deleted.</tp:docstring>
                </arg>
            </method>

            <signal name='Crash'>
                <tp:docstring>A new system problem has been detected.</tp:docstring>

                <arg type='o' name='problem_object' direction='out'>
                    <tp:docstring>An identifier of the newly created problem.</tp:docstring>
                </arg>

                <arg type='s' name='uid' direction='out'>
                    <tp:docstring>UID of user who reported this problem.</tp:docstring>
                </arg>
            </signal>

        </interface>

    </node>

    <!--
     * ======================================================================================
     * Problems Entry Interface
     *
    -->

    <node name='/org/freedesktop/Problems2/xxx'>

        <interface name='org.freedesktop.Problems2.Entry'>
            <tp:docstring>The Entry represents single problem.</tp:docstring>

            <property name='id' type='s' access='read'>
                <tp:docstring>The unix time when the collection was created.</tp:docstring>
            </property>

            <property name='uid' type='u' access='read'>
                <tp:docstring>The uid of the crashed program.</tp:docstring>
            </property>

            <property name='username' type='s' access='read'>
                <tp:docstring>The user name associated with the uid.</tp:docstring>
            </property>

            <property name='type' type='s' access='read'>
                <tp:docstring>The type of the problem (CCpp, Python, Kerneloops, Java, Ruby).</tp:docstring>
            </property>

            <property name='detected' type='t' access='read'>
                <tp:docstring>The unix time when the problem entry was created.</tp:docstring>
            </property>

            <property name='last_occurrence' type='t' access='read'>
                <tp:docstring>The unix time when the problem entry was seen for the last time.</tp:docstring>
            </property>

            <property name='count' type='u' access='read'>
                <tp:docstring>The number of observed problem's occurrences.</tp:docstring>
            </property>

            <property name='executable' type='s' access='read'>
                <tp:docstring>The file system path to crashed program.</tp:docstring>
            </property>

            <property name='command_line_arguments' type='s' access='read'>
                <tp:docstring>The command line arguments used run the crashed program.</tp:docstring>
            </property>

            <property name='component' type='s' access='read'>
                <tp:docstring>The component which the package belogns to.</tp:docstring>
            </property>

            <property name='package' type='(sssss)' access='read'>
                <tp:docstring>Full name, epoch, name, version, release of the package which the crashed program belongs to.</tp:docstring>
            </property>

            <property name='uuid' type='s' access='read'>
                <tp:docstring>A local scope, unique identifier for similar problems to the problem.</tp:docstring>
            </property>

            <property name='duphash' type='s' access='read'>
                <tp:docstring>A global scope, unique identifier for similar problems to the problem.</tp:docstring>
            </property>

<!--
Property "reports":
===================
libreports 'repoted_to' contains known reports of a problem. Every report is
stored in a form of a single line. Every 'reported_to' line is prefixed with
"label" followed ":". We will use term 'title' instead of 'label.
libreport recognizes three value types on lines of 'reported_to' element:
1. text message
2. URL (Bugzilla, e-mail, upload, RHSupport)
3. BTHASH (uReport)

One might presume the list will grow in the future with the growing number of
report types and supported bug trackers. Hence the API should not have
hard-coded types and should be able to easily start supporting new
'reported_to' types. This goal is in D-Bus APIs achieved by using dictionaries
with the value of the type Variant and a string key (a{sv}).

Know keys:
    * MSG - a text description of the report
    * URL - an URL to the report
    * BTHASH - a global uReport identifier

The final type of the property 'reports' would be "a(sa{sv})".

Example:

file "reported_to":
    Bugzilla: URL=https://bugzill.example.com/1000000
    Bugzilla: URL=https://bugzill.example.com/1234567
    email: URL=mailto://bugs@example-project.org
    ABRT Server: BTHASH=DEADBEFF81680083
    RHTSupport: URL=https://support.corp.com/ticket=12345 MSG=New customer case 12345

property "reports":
    [
        ( "Bugzilla",
            { "URL" : "https://bugzill.example.com/1000000" }
        ),
        ( "Bugzilla",
            { "URL" : "https://bugzill.example.com/1234567" },
        ),
        ( "email",
            { "URL" : "mailto://bugs@example-project.org" }
        ),
        ( "ABRT Server",
            { "BTHASH" : "DEADBEFF81680083" },
        ),
        ( "RHTSupport",
            { "URL" : "https://support.corp.com/ticket=12345",
              "MSG" : "New customer case 12345" }
        )
    ]

Note:

We will not convert the format of reported_to to JSON and use it for storing
solutions, because the solutions will have own element and the file reported_to
is just a list of reports and should not be overloaded.
-->

<!--
TODO:
We have to provide a way to edit the reports (add/remove/update) without
the need to touch raw data.
-->
            <property name='reports' type='a{sa{sv}}' access='read'>
            <!-- <property name='reports' type='a{sss}' access='read'> -->
                <tp:docstring>The list of reports of the problem in the form of a dictionary where the key is the report type (e.g. Bugzilla, ABRT Server) and the value is another dictionary with the report informations (URL, "https://bugzilla.redhat.com/1000000").</tp:docstring>
            </property>

            <property name='reason' type='s' access='read'>
                <tp:docstring>A brief description of what caused the problem.</tp:docstring>
            </property>

            <property name='resolution' type='s' access='read'>
                <tp:docstring>More technical details about the problem usally containing explanation for the not-reporatiblity of the problem (e.g tainted Kernel oopses).</tp:docstring>
            </property>

            <property name='desktop_file' type='s' access='read'>
                <tp:docstring>The name of system desktop file used to start the program. This property is set to some value only if the program was started as an application, the application was found and the program is shipped with a system package (i.e. this property is empty for crashes of user application).</tp:docstring>
            </property>

            <property name='elements' type='as' access='read'>
                <tp:docstring>List of all elements the problem have.</tp:docstring>
            </property>

            <property name='is_reported' type='b' access='read'>
                <tp:docstring>True if someone took the time to file a ticket in the bugctracking system of OS.</tp:docstring>
            </property>

            <property name='is_reportable' type='b' access='read'>
                <tp:docstring>True if it is possible to file a ticket in the bugctracking system of OS.</tp:docstring>
            </property>
<!--
TODO:
Generic property getter
=======================

It is expectable that we will need to add new properties. We can handle it by
adding a new D-Bus property and force consumers to write their code ready for
the missing properties or we can add a method returning variant or better a{sv}.
-->

<!--
Getters and setters
===================
We need to decided whether we want have more, specialized functions or less,
configurable functions. According to D-Bus API Design Guidelines, it is a good
idea to use flag fields in method calls.

There is a question that needs to be answered for both approaches:
1. What should happen if the caller wants an element of not supported type?


Use the type Variable in the getters:
`````````````````````````````````````
method GetTextElements(in as, out a{ss})
    returns a list of values of text elements
    1. return an error or treat it as missing

and method OpenElements(in as, out a{su})
    returns a list of file descriptors to both kind of elements
    1. everything is a file descriptor, so the caller has to recognize the
       type of the elements on his own

OR:

method ReadElements(in asi, out a{sv})
    returns binary elements as UNIX file descriptors and text elements as strings
    i == flags
        * NO FLAGS -> open both binary and text elements
        * ALL FD -> return everything as UNIX file descriptors
        * ONLY TEXT -> get only text elements
        * ONLY BINARY -> get only binary elements
        ? ONLY BIG TEXT -> or treat this as BINARY?

    1. client has to recognize the return type and behave appropriately
     1.a (ONLY TEXT) return an error or treat it as missing
     1.b (ONLY TEXT | ALL FD) the caller knows what to do
     1.c (ONLY BINARY) the caller has to recognize the type of the elements on
         his own
     1.d (ONLY BINARY | ALL FD) the same as 1.c

The method ReadElements is more error prone because clients need to write code
checking the return type. But the method is more flexible because of the
argument flags, so it would be better to use this variant.


Use the type Variable in the setters:
`````````````````````````````````````
method SaveTextElements(in ass)
method SaveElements(in asu)

OR:

method SaveElements(in asv)

The Variable variant is definitely more convenient for users!
-->

            <method name='ReadElements'>
                <tp:docstring>Gets a value of problem's element which are store as text files.</tp:docstring>

                <arg type='as' name='element_names' direction='in'>
                    <tp:docstring>A list of names of required info. If type of a requested element does not match the type specified in the argument 'i', the element will be ignored and its value will not be included in the response.</tp:docstring>
                </arg>

                <arg type='i' name='flags' directory='in'>
                    <tp:docstring>NO_FALGS, ALL_FD, ALL_ELEMENTS, ONLY_TEXT, ONLY_BIG_TEXT, ONLY_BINARY</tp:docstring>
                </arg>

                <arg type='a{sv}' name='response' direction='out'>
                    <tp:docstring>A list of values of the requested elements.</tp:docstring>
                </arg>
                <tp:docstring>
                    <example id="ReadElements_example_python">
                        <title>How to use ReadElements() method to print out a nice list of problems</title>
                        <programlisting>
<![CDATA[
#!/usr/bin/env python
from sys import stdout
import dbus
from datetime import datetime

bus = dbus.SystemBus()

proxy = bus.get_object("org.freedesktop.problems",
                          '/org/freedesktop/problems2')

problems = dbus.Interface(proxy, dbus_interface='org.freedesktop.Problems2')

for prblmprx in problems.GetProblems():
    prblm  = dbus.Interface(prblmprx, dbus_interface='org.freedesktop.Problems.Entry')
    kv = prblm.ReadElements(prblmid, ["time", "count", "package", "reason"], ONLY_TEXT)

    date = datetime.fromtimestamp(float(kv["time"]))
    count = int(kv.get("count", 0))
    package = str(kv.get("package", ""))
    reason = str(kv.get("reason", ""))

    stdout.write("{0} {1:-3} {2:30} : {3}\n".format(date, count, package, reason))
]]>
                        </programlisting>
                    </example>
                </tp:docstring>

            </method>

            <method name='SaveElements'>
                <tp:docstring>Creates or updates problem elements for file descriptors.</tp:docstring>

                <arg type='a{sv}' name='name' direction='in'>
                    <tp:docstring>The problem elements with their file descriptors.</tp:docstring>
                </arg>

                <arg type='i' name='flags' direction='in'>
                    <tp:docstring>This argument might be used in future to allow the caller to choose whether he want to overrite the elements of truncate them.</tp:docstring>
                </arg>

            </method>

            <method name='DeleteElements'>
                <tp:docstring>Deletes problem's element.</tp:docstring>

                <arg type='as' name='name' direction='in'>
                    <tp:docstring>The list of deleted problem element.</tp:docstring>
                </arg>

            </method>

        </interface>

    </node>

    <!--
     * ======================================================================================
     * Session Interface
     *
    -->

    <node name='/org/freedesktop/Problems2/session/xxx'>

        <interface name='org.freedesktop.Problems2.Session'>
            <tp:docstring>The Session holds information about the client</tp:docstring>

            <property name='is_authorized' type='b' access='read'>
                <tp:docstring>TODO</tp:docstring>
            </property>

            <method name='Authorize'>
                <tp:docstring>TODO</tp:docstring>
            </method>

            <method name='Close'>
                <tp:docstring>TODO</tp:docstring>
            </method>

        </interface>

    </node>

</tp:spec>
